ANCHOR APP - Master Development Prompt for Claude Code
CRITICAL: Read This First
You are building Anchor, a premium mobile app that transforms written intentions into powerful visual symbols (sigils) using chaos magick methodology + modern AI art generation. This is a complete, production-ready app that will be launched to the App Store and Google Play.
Complete technical specification: See Anchor_App_Comprehensive_Handoff_Document.pdf (uploaded separately)
Your role: Implement features incrementally following the development phases outlined in the handoff document. Each task should be focused, complete, and production-quality.

PROJECT OVERVIEW
What We're Building

Product: "Anchor" - Visual Goal Setting / Intentional Living App
Core Flow: User enters intention ‚Üí Letters distilled ‚Üí Merged into sigil ‚Üí AI enhancement ‚Üí Mantra creation ‚Üí Charging ritual ‚Üí Daily activation
Positioning: Mainstream "Visual Goal Setting" (not occult-branded)
Monetization: Freemium ($4.99/mo Pro) + Print-on-Demand Merch
Timeline: 10-12 weeks MVP to full product

Tech Stack
Frontend: React Native + TypeScript
Backend: Node.js + Express + TypeScript
Database: PostgreSQL + Redis
AI: Stable Diffusion XL (via Replicate API)
Auth: Firebase
Payments: RevenueCat
Storage: Cloudflare R2

HOW TO WORK WITH ME
Task Sizing Principles
‚úÖ GOOD TASK SIZE (One Claude Code Session):

"Create the letter distillation algorithm in TypeScript"
"Build IntentionInputScreen with validation"
"Implement Quick Charge ritual with haptics"
"Create Vault grid view with pull-to-refresh"
"Set up Prisma database schema for anchors table"

‚ùå TOO BROAD (Will fail):

"Build the entire anchor creation system"
"Implement all rituals"
"Create the backend API"

‚ùå TOO NARROW (Inefficient):

"Add a button to the screen"
"Change the color of text"

Golden Rule
One focused feature or component per session. If it takes more than 200 lines of code or touches more than 3 files significantly, it's probably too big.

DEVELOPMENT PHASES (From Handoff Doc)
Phase 0: Setup (Week 1)

Initialize React Native project with TypeScript
Set up Express backend with Prisma
Configure database schema
Set up Firebase Auth
Install core dependencies

Phase 1: MVP Core (Weeks 2-4)
Goal: Users can create, charge, and activate basic anchors
Tasks in order:

Authentication & Onboarding
Letter Distillation Algorithm
Traditional Sigil Generator
First Anchor Creation Flow
Basic Vault
Charging Rituals
Basic Activation

Phase 2: AI Enhancement (Weeks 5-6)
Goal: Intelligent symbol selection and generation
Tasks in order:

Intention Analysis System
AI Prompt Constructor
Stable Diffusion Integration
AI Enhancement Flow UI

Phase 3: Advanced Features (Weeks 7-9)
Goal: Full feature set
Tasks in order:

Mantra System
Deep Charge Ritual
Manual Forge
Burning Ritual
Vault Organization
Discover Feed

Phase 4: Monetization & Polish (Weeks 10-12)
Goal: Production-ready
Tasks in order:

Subscription System (RevenueCat)
Merch Shop (Printful)
Push Notifications
Offline Mode
Stats Dashboard
Testing & Polish


TASK REQUEST FORMAT
When I give you a task, I'll provide:

Task Description: What to build
Location: Where files should be created
Specifications: Reference to handoff doc section
Dependencies: What it connects to
Acceptance Criteria: How to know it's done

Example Task Request
TASK: Create Letter Distillation Algorithm

LOCATION: 
- src/utils/sigil/distillation.ts
- src/utils/sigil/distillation.test.ts

SPECIFICATIONS:
See Section 5.1 of handoff document.

REQUIREMENTS:
1. Function: distillIntention(text: string): DistillationResult
2. Remove spaces from input
3. Remove vowels (a, e, i, o, u) - case insensitive
4. Remove duplicate letters (keep first occurrence)
5. Return uppercase letters array

INTERFACE:
interface DistillationResult {
  original: string;
  final_letters: string[];
  removed_vowels: string[];
  removed_duplicates: string[];
}

TESTS:
Include Jest unit tests covering:
- Basic distillation: "Close the deal" ‚Üí ["C","L","O","S","T","H","D"]
- Case handling
- Empty string handling
- Special characters handling

ACCEPTANCE CRITERIA:
- All tests pass
- TypeScript types properly defined
- Code documented with JSDoc comments
- Example usage shown

CODE QUALITY STANDARDS
TypeScript Requirements

Always use interfaces for component props
Explicit return types for all functions
Strict mode enabled - no implicit any
Use optional chaining (?.) and nullish coalescing (??)

File Naming

PascalCase for components: Button.tsx, AnchorCard.tsx
camelCase for utilities: distillation.ts, apiClient.ts
kebab-case for assets: icon-gold-star.png

Code Style

Prettier formatting (run before committing)
ESLint rules (Airbnb style guide)
No console.logs in production code (use proper logging)
Error handling on all async operations

Testing Requirements

Unit tests for all algorithms and utilities
Integration tests for complex flows
Test coverage minimum 70% for critical paths

Documentation

JSDoc comments for all exported functions
README for each major feature directory
Inline comments for complex logic only


DESIGN SYSTEM (Always Follow)
Colors (Zen Architect Theme)
typescriptcolors = {
  charcoal: '#1A1A1D',    // Primary background
  navy: '#0F1419',        // Secondary background
  gold: '#D4AF37',        // Primary accent, CTAs
  bone: '#F5F5DC',        // Primary text
  deepPurple: '#3E2C5B',  // Accent
  bronze: '#CD7F32',      // Secondary accent
  silver: '#C0C0C0'       // Secondary text
}
Typography
typescriptfonts = {
  heading: 'Cinzel-Regular',      // Elegant serif
  body: 'Inter-Regular',          // Clean sans-serif
  mono: 'RobotoMono-Regular'      // Code/technical
}

sizes = {
  h1: 32, h2: 24, h3: 20, h4: 18,
  body1: 16, body2: 14,
  caption: 12, button: 16
}
Spacing
typescriptspacing = {
  xs: 4, sm: 8, md: 16, lg: 24,
  xl: 32, xxl: 48, xxxl: 64
}
ALWAYS use these values. No arbitrary spacing like marginTop: 13 - use the spacing scale.

API PATTERNS
Backend Endpoint Structure
typescript// Standard response format
{
  success: boolean;
  data?: any;
  error?: {
    code: string;
    message: string;
  };
  meta?: {
    page?: number;
    total?: number;
  };
}
Frontend API Calls
typescript// Always handle loading, success, and error states
const [data, setData] = useState(null);
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);

try {
  setLoading(true);
  const result = await api.createAnchor(data);
  setData(result);
} catch (err) {
  setError(err.message);
  // Show user-friendly error
} finally {
  setLoading(false);
}

DATABASE CONVENTIONS
Table Names

Plural, lowercase: users, anchors, activations

Column Names

Snake_case: created_at, user_id, is_charged

Primary Keys

Always UUID: id UUID PRIMARY KEY DEFAULT gen_random_uuid()

Timestamps

Always include: created_at TIMESTAMP DEFAULT NOW()
Include updated_at for mutable data

Foreign Keys

Always with ON DELETE: user_id UUID REFERENCES users(id) ON DELETE CASCADE


CRITICAL ALGORITHMS (Reference Handoff Doc Sections)
1. Letter Distillation (Section 5.1)
Location: utils/sigil/distillation.ts
Method: Austin Osman Spare
Steps: Remove spaces ‚Üí Remove vowels ‚Üí Remove duplicates
2. Traditional Sigil Generator (Section 5.2)
Location: utils/sigil/traditional-generator.ts
Output: 3 SVG variations (dense, balanced, minimal)
Method: Merge letter vectors, find connections, apply styles
3. Intention Analysis (Section 5.3)
Location: backend/services/IntentionAnalyzer.ts
Method: NLP keyword extraction ‚Üí Theme mapping ‚Üí Symbol selection
4. Mantra Generation (Section 5.4)
Location: utils/mantra/generator.ts
Styles: Syllabic, Rhythmic, Letter-by-letter

COMMON PITFALLS TO AVOID
‚ùå Don't Do This:

Creating files outside project structure
Using hard-coded values instead of theme constants
Skipping error handling
Writing components without TypeScript types
Missing loading states on async operations
Forgetting to update related files when changing interfaces
Using any type
Leaving console.logs in code

‚úÖ Do This:

Follow the folder structure exactly
Use theme constants for all colors/spacing
Handle errors gracefully with user feedback
Define proper TypeScript interfaces
Show loading spinners for all async operations
Update all dependent code when changing interfaces
Use proper types (even if complex)
Use proper logging library


TESTING CHECKLIST
Before marking a task complete, verify:

 Code compiles without TypeScript errors
 All imports resolve correctly
 Unit tests written and passing
 ESLint passes (no warnings)
 Prettier formatting applied
 No console.logs remaining
 Error handling implemented
 Loading states implemented (for async)
 TypeScript interfaces properly defined
 JSDoc comments added for exported functions
 Tested on iOS simulator (if frontend)
 Tested on Android emulator (if frontend)


WHEN TO ASK FOR CLARIFICATION
ASK if:

Task requirements are ambiguous
Multiple valid implementation approaches exist
Unclear which section of handoff doc to reference
Dependencies are missing or unclear
Design decision needed (not specified in handoff doc)

DON'T ASK about:

How to structure React components (follow best practices)
How to name variables (use clear, descriptive names)
Whether to add comments (yes, for complex logic)
Whether to handle errors (always yes)


FILE STRUCTURE REFERENCE
src/
‚îú‚îÄ‚îÄ screens/              # Full-screen views
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îú‚îÄ‚îÄ create/          # Anchor creation flow
‚îÇ   ‚îú‚îÄ‚îÄ rituals/         # Charging and activation
‚îÇ   ‚îî‚îÄ‚îÄ vault/
‚îú‚îÄ‚îÄ components/           # Reusable UI components
‚îÇ   ‚îú‚îÄ‚îÄ buttons/
‚îÇ   ‚îú‚îÄ‚îÄ cards/
‚îÇ   ‚îú‚îÄ‚îÄ inputs/
‚îÇ   ‚îî‚îÄ‚îÄ modals/
‚îú‚îÄ‚îÄ navigation/           # React Navigation
‚îú‚îÄ‚îÄ services/             # Business logic, API calls
‚îÇ   ‚îú‚îÄ‚îÄ AuthService.ts
‚îÇ   ‚îú‚îÄ‚îÄ StorageService.ts
‚îÇ   ‚îî‚îÄ‚îÄ ApiClient.ts
‚îú‚îÄ‚îÄ utils/                # Pure functions, helpers
‚îÇ   ‚îú‚îÄ‚îÄ sigil/
‚îÇ   ‚îî‚îÄ‚îÄ mantra/
‚îú‚îÄ‚îÄ hooks/                # Custom React hooks
‚îú‚îÄ‚îÄ theme/                # Colors, typography, spacing
‚îÇ   ‚îú‚îÄ‚îÄ colors.ts
‚îÇ   ‚îú‚îÄ‚îÄ typography.ts
‚îÇ   ‚îî‚îÄ‚îÄ spacing.ts
‚îú‚îÄ‚îÄ types/                # TypeScript types/interfaces
‚îî‚îÄ‚îÄ assets/               # Images, fonts, sounds
    ‚îú‚îÄ‚îÄ images/
    ‚îú‚îÄ‚îÄ fonts/
    ‚îî‚îÄ‚îÄ sounds/

EXAMPLE: FIRST TASK
Here's what our first real development task will look like:
TASK: Create Letter Distillation Algorithm

I need you to implement the core letter distillation algorithm that removes 
vowels and duplicates from user intentions, following the Austin Osman Spare 
method for sigil creation.

LOCATION: 
src/utils/sigil/distillation.ts
src/utils/sigil/distillation.test.ts

FULL SPECIFICATION:
See Section 5.1 of the Anchor_App_Comprehensive_Handoff_Document.pdf

REQUIREMENTS:
1. Create function: distillIntention(text: string): DistillationResult
2. Remove all spaces from input
3. Remove vowels: a, e, i, o, u (case-insensitive)
4. Remove duplicate letters (keep first occurrence only)
5. Return array of uppercase letters

INTERFACE DEFINITION:
interface DistillationResult {
  original: string;                 // Original input text
  final_letters: string[];          // Final distilled letters
  removed_vowels: string[];         // Array of removed vowels
  removed_duplicates: string[];     // Array of removed duplicate letters
}

TEST CASES:
1. "Close the deal" ‚Üí ["C","L","O","S","T","H","D"]
2. "Find inner peace" ‚Üí ["F","N","D","R","P","C"]
3. "Launch my startup" ‚Üí ["L","N","C","H","M","Y","S","T","R","P"]
4. Empty string ‚Üí []
5. Only vowels "aeiou" ‚Üí []
6. Mixed case "HeLLo WoRLd" ‚Üí ["H","L","O","W","R","D"]

DELIVERABLES:
1. distillation.ts with the algorithm
2. distillation.test.ts with Jest tests for all cases above
3. JSDoc comments documenting the function
4. Example usage in comments

ACCEPTANCE CRITERIA:
‚úì All tests pass
‚úì TypeScript compiles without errors
‚úì Code formatted with Prettier
‚úì Function properly typed (no 'any')
‚úì Edge cases handled (empty string, special chars, numbers)

NOTES:
- This is a pure function (no side effects)
- Should be fast (O(n) time complexity)
- Keep it simple and readable
- This will be called every time a user creates an anchor

COMMUNICATION STYLE
What I'll Give You Each Task:

Clear task description
File locations
Specification reference
Requirements list
Acceptance criteria

What I Expect From You:

Confirm understanding before coding
Ask questions if anything is unclear
Show me the code when done
Explain key decisions you made
List any assumptions you made

If You Hit a Blocker:

Explain what's blocking you
Show what you've tried
Ask specific questions
Suggest alternatives if possible


QUALITY OVER SPEED
Important: We're building a production app that will be used by thousands of people and generate revenue. Code quality matters more than speed.
Take the time to:

Write clean, readable code
Add proper error handling
Write comprehensive tests
Document complex logic
Consider edge cases

Don't rush:

"It works on my machine" isn't good enough
"I'll add tests later" means never
"Good enough for now" creates technical debt


REMEMBER THE VISION
You're not just writing code. You're building a tool that helps people:

Clarify their intentions
Focus their mental energy
Achieve their goals
Feel empowered and motivated

Every screen, every animation, every interaction should feel:

Intentional (not random)
Elegant (not cluttered)
Powerful (not gimmicky)
Personal (not generic)

The best code is code that creates a magical user experience.

READY TO START?
When you're ready, I'll give you the first task following this format. We'll work through the development phases incrementally, building production-quality features one at a time.
Current Phase: Phase 0 - Project Setup
Next Task: Initialize React Native project with TypeScript
Let me know when you're ready to begin! üéØ